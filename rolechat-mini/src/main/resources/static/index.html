<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RoleChat Mini - AI角色扮演语音聊天</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #4361ee;
      --secondary-color: #3f37c9;
      --accent-color: #4cc9f0;
      --light-color: #f8f9fa;
      --dark-color: #212529;
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
      --gray-color: #6c757d;
      --light-gray: #e9ecef;
      --border-radius: 10px;
      --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: var(--dark-color);
      line-height: 1.6;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
    }

    h1 {
      color: var(--primary-color);
      margin-bottom: 10px;
      font-size: 2.5rem;
    }

    .subtitle {
      color: var(--gray-color);
      font-size: 1.1rem;
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 25px;
      margin-bottom: 25px;
      transition: var(--transition);
    }

    .card:hover {
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    }

    .search-section {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }

    #q {
      flex: 1;
      padding: 12px 15px;
      border: 2px solid var(--light-gray);
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
    }

    #q:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(76, 201, 240, 0.2);
    }

    button {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      padding: 12px 20px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button:hover {
      background: var(--secondary-color);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--light-gray);
      color: var(--dark-color);
    }

    .btn-secondary:hover {
      background: #d1d1d1;
    }

    .btn-success {
      background: var(--success-color);
    }

    .btn-success:hover {
      background: #3d8b40;
    }

    #roles {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 20px;
    }

    .role-card {
      background: var(--light-color);
      border-radius: var(--border-radius);
      padding: 15px;
      cursor: pointer;
      transition: var(--transition);
      border: 2px solid transparent;
      width: calc(33.333% - 10px);
      text-align: center;
    }

    .role-card:hover {
      transform: translateY(-5px);
      border-color: var(--accent-color);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .role-card.selected {
      border-color: var(--primary-color);
      background: rgba(67, 97, 238, 0.1);
    }

    .role-icon {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: var(--primary-color);
    }

    .role-title {
      font-weight: 600;
      margin-bottom: 5px;
    }

    .role-desc {
      font-size: 0.85rem;
      color: var(--gray-color);
    }

    .chat-container {
      position: relative;
    }

    #chat {
      height: 400px;
      overflow-y: auto;
      padding: 20px;
      border-radius: var(--border-radius);
      background: var(--light-color);
      margin-bottom: 20px;
      border: 1px solid var(--light-gray);
    }

    .msg {
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 18px;
      max-width: 80%;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .user {
      background: var(--primary-color);
      color: white;
      margin-left: auto;
      border-bottom-right-radius: 5px;
    }

    .ai {
      background: var(--light-gray);
      color: var(--dark-color);
      margin-right: auto;
      border-bottom-left-radius: 5px;
    }

    #input {
      width: 100%;
      padding: 15px;
      border: 2px solid var(--light-gray);
      border-radius: var(--border-radius);
      font-size: 1rem;
      resize: vertical;
      min-height: 100px;
      margin-bottom: 15px;
      transition: var(--transition);
    }

    #input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(76, 201, 240, 0.2);
    }

    .action-buttons {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }

    #player {
      width: 100%;
      margin-top: 15px;
      border-radius: var(--border-radius);
    }

    .typing-indicator {
      display: none;
      padding: 12px 15px;
      background: var(--light-gray);
      border-radius: 18px;
      margin-bottom: 15px;
      width: fit-content;
      border-bottom-left-radius: 5px;
    }

    .typing-indicator span {
      height: 10px;
      width: 10px;
      background: var(--gray-color);
      border-radius: 50%;
      display: inline-block;
      margin: 0 2px;
      animation: bounce 1.3s linear infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.15s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.3s;
    }

    @keyframes bounce {
      0%, 60%, 100% {
        transform: translateY(0);
      }
      30% {
        transform: translateY(-5px);
      }
    }

    footer {
      text-align: center;
      margin-top: 30px;
      color: var(--gray-color);
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      .search-section {
        flex-direction: column;
      }
      
      .role-card {
        width: calc(50% - 10px);
      }
      
      .action-buttons {
        flex-direction: column;
      }
      
      .msg {
        max-width: 90%;
      }
    }

    @media (max-width: 480px) {
      .role-card {
        width: 100%;
      }
      
      h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><i class="fas fa-robot"></i> RoleChat Mini</h1>
      <p class="subtitle">AI角色扮演语音聊天系统</p>
    </header>

    <div class="card">
      <h2><i class="fas fa-search"></i> 选择角色</h2>
      <div class="search-section">
        <input id="q" placeholder="搜索角色，如 苏格拉底 / 哈利波特" />
        <button onclick="searchRoles()">
          <i class="fas fa-search"></i> 搜索
        </button>
      </div>
      <div id="roles">
        <!-- 角色卡片将在这里显示 -->
      </div>
    </div>

    <div class="card chat-container">
      <h2><i class="fas fa-comments"></i> 聊天对话</h2>
      <div id="chat">
        <div class="welcome-message">
          <p>欢迎使用RoleChat Mini！</p>
          <p>1. 在上方搜索并选择一个角色</p>
          <p>2. 输入消息或使用语音功能开始对话</p>
          <p>3. 点击"TTS播放"听取AI回复</p>
        </div>
      </div>
      
      <div class="typing-indicator" id="typingIndicator">
        <span></span>
        <span></span>
        <span></span>
      </div>

      <textarea id="input" placeholder="输入内容，或点击'TTS播放'听AI声音"></textarea>
      
      <div class="action-buttons">
        <button onclick="startStream()">
          <i class="fas fa-paper-plane"></i> 发送消息
        </button>
        <button class="btn-success" onclick="playTts()">
          <i class="fas fa-volume-up"></i> TTS播放最后回复
        </button>
        <button class="btn-secondary" onclick="clearChat()">
          <i class="fas fa-trash"></i> 清空聊天
        </button>
        <!-- 添加录音按钮 -->
        <button id="recordButton" onclick="startRecording()">
          <i class="fas fa-microphone"></i> <span id="recordText">开始录音</span>
        </button>
        <button id="stopRecordButton" onclick="stopRecording()" disabled>
          <i class="fas fa-stop"></i> 停止录音
        </button>
      </div>
      
      <audio id="player" controls></audio>
    </div>

    <footer>
      <p>RoleChat Mini - AI角色扮演语音聊天系统</p>
    </footer>
  </div>

  <script>
    let selectedRole = null;
    let lastAiText = '';
    let roleName = '';

    // 页面加载时搜索所有角色
    window.onload = function() {
      searchRoles();
    };

    async function searchRoles(){
      const q = document.getElementById('q').value;
      const res = await fetch(`/api/roles/search?q=${encodeURIComponent(q||'')}`);
      const data = await res.json();
      const box = document.getElementById('roles');
      
      if (data.length === 0) {
        box.innerHTML = '<p>未找到相关角色</p>';
        return;
      }
      
      box.innerHTML = data.map(r => `
        <div class="role-card ${selectedRole === r.id ? 'selected' : ''}" onclick="sel('${r.id}', '${r.title}')">
          <div class="role-icon">
            ${getRoleIcon(r.title)}
          </div>
          <div class="role-title">${r.title}</div>
          <div class="role-desc">${r.remark}</div>
        </div>
      `).join(' ');
    }
    
    function getRoleIcon(roleTitle) {
      if (roleTitle.includes('苏格拉底')) return '<i class="fas fa-question"></i>';
      if (roleTitle.includes('哈利')) return '<i class="fas fa-broom"></i>';
      if (roleTitle.includes('英语')) return '<i class="fas fa-language"></i>';
      return '<i class="fas fa-user"></i>';
    }

    function sel(id, title){
      selectedRole = id;
      roleName = title;
      searchRoles(); // 重新渲染以更新选中状态
      showMessage(`已选择角色: ${title}`, 'system');
    }
    
    function showMessage(text, role) {
      const chat = document.getElementById('chat');
      const div = document.createElement('div');
      div.className = `msg ${role}`;
      
      if (role === 'system') {
        div.innerHTML = `<strong>系统:</strong> ${text}`;
      } else {
        const roleText = role === 'user' ? '我' : (roleName || 'AI');
        div.textContent = `${roleText}: ${text}`;
      }
      
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function addMsg(role, text){
      const chat = document.getElementById('chat');
      const div = document.createElement('div');
      div.className = `msg ${role}`;
      
      const roleText = role === 'user' ? '我' : (roleName || 'AI');
      div.textContent = `${roleText}: ${text}`;
      
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function startStream(){
      if(!selectedRole){ 
        showMessage('请先选择角色', 'system');
        return; 
      }
      
      const text = document.getElementById('input').value;
      if (!text.trim()) {
        showMessage('请输入消息内容', 'system');
        return;
      }
      
      addMsg('user', text);
      document.getElementById('input').value = '';
      
      // 显示打字指示器
      document.getElementById('typingIndicator').style.display = 'block';
      
      const es = new EventSourcePolyfill('/api/chat/stream', {
        headers: { 'Content-Type':'application/json' },
        payload: JSON.stringify({ roleId:selectedRole, userText:text, answerContentType:'text' }),
        method: 'POST'
      });
      
      let acc = '';
      es.onmessage = (e)=>{
        try{
          // 忽略空数据或心跳数据
          if (!e.data || e.data.trim() === '' || e.data.trim() === 'data:') {
            return;
          }

          // 处理流结束标记
          if (e.data === '[DONE]' || e.data.includes('[DONE]')) {
            es.close();
            lastAiText = acc;
            // 隐藏打字指示器
            document.getElementById('typingIndicator').style.display = 'none';
            // 滚动到底部
            const chat = document.getElementById('chat');
            chat.scrollTop = chat.scrollHeight;
            return;
          }

          // 确保数据以 "data:" 开头
          let jsonData = e.data;
          if (e.data.startsWith('data:')) {
            jsonData = e.data.substring(5).trim();
          }

          // 再次检查是否为空
          if (!jsonData || jsonData.trim() === '') {
            return;
          }

          // 尝试解析JSON
          const obj = JSON.parse(jsonData);
          const delta = obj.choices?.[0]?.delta?.content || '';
          if(delta){ 
            if (acc === '') {
              // 第一个消息片段，创建消息元素
              const chat = document.getElementById('chat');
              const div = document.createElement('div');
              div.className = 'msg ai';
              div.textContent = `${roleName || 'AI'}: ${delta}`;
              chat.appendChild(div);
              acc += delta;
              chat.scrollTop = chat.scrollHeight;
            } else {
              // 更新最后一个消息元素
              const chat = document.getElementById('chat');
              const lastMsg = chat.lastChild;
              if (lastMsg && lastMsg.classList.contains('ai')) {
                lastMsg.textContent = `${roleName || 'AI'}: ${acc + delta}`;
                acc += delta;
                chat.scrollTop = chat.scrollHeight;
              }
            }
          }
       }catch(err){
          console.error('Error parsing message:', err, 'Raw data:', e.data);
        }
      };
      
      es.onerror = ()=>{
        es.close(); 
        lastAiText = acc; 
        // 隐藏打字指示器
        document.getElementById('typingIndicator').style.display = 'none';
        // 滚动到底部
        const chat = document.getElementById('chat');
        chat.scrollTop = chat.scrollHeight;
      };
    }

    async function playTts(){
      if(!lastAiText){ 
        showMessage('暂无可播放文本', 'system');
        return; 
      }
      
      try {
        showMessage('正在生成语音...', 'system');
        const r = await fetch('/api/chat/tts', { 
          method:'POST', 
          headers:{'Content-Type':'application/json'}, 
          body: JSON.stringify({ text:lastAiText })
        });
        
        if (!r.ok) {
          throw new Error(`HTTP error! status: ${r.status}`);
        }
        
        const j = await r.json();
        const audio = document.getElementById('player');
        
        // 检查响应数据
        if (j.audioBase64) {
          // 检查是否是错误信息而不是真正的音频
          try {
            const decodedData = atob(j.audioBase64);
            if (decodedData.includes('[TTS错误]')) {
              showMessage('TTS服务错误: ' + decodedData, 'system');
              return;
            }
            
            if (decodedData.includes('TTS服务未返回音频数据')) {
              showMessage('TTS服务未返回音频数据', 'system');
              return;
            }
          } catch (e) {
            // 如果解码失败，可能是有效的base64音频数据
            console.log('Could not decode base64 as text, treating as audio data');
          }
          
          try {
            // 直接创建 ArrayBuffer 并播放
            const binary = atob(j.audioBase64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
              bytes[i] = binary.charCodeAt(i);
            }

            // 创建 Blob，尝试多种 MIME 类型
            const blob = new Blob([bytes], { type: 'audio/mpeg' });
            const url = URL.createObjectURL(blob);

            // 先测试音频是否可以播放
            const audioTest = new Audio();
            audioTest.addEventListener('canplaythrough', () => {
              console.log('Audio can play through');
            });

            audioTest.addEventListener('error', (e) => {
              console.error('Audio test error:', e);
              // 尝试其他 MIME 类型
              const blobWav = new Blob([bytes], { type: 'audio/wav' });
              const urlWav = URL.createObjectURL(blobWav);
              audio.src = urlWav;
            });

            audio.src = url;

            // 监听播放事件
            audio.onplay = () => {
              showMessage('开始播放语音...', 'system');
            };

            audio.oncanplay = () => {
              console.log('Audio can play');
            };

            audio.onloadeddata = () => {
              console.log('Audio data loaded');
            };

            audio.onerror = (e) => {
              console.error('Audio play error:', e);
              console.log('Audio error code:', audio.error?.code);
              showMessage('音频播放失败: ' + (audio.error?.message || '未知错误'), 'system');
            };

            // 等待一小段时间确保音频加载完成后再播放
            setTimeout(async () => {
              try {
                await audio.play();
              } catch (playError) {
                console.error('Playback failed:', playError);
                // 尝试使用 WAV 格式
                try {
                  const blobWav = new Blob([bytes], { type: 'audio/wav' });
                  const urlWav = URL.createObjectURL(blobWav);
                  audio.src = urlWav;
                  await audio.play();
                } catch (wavError) {
                  console.error('WAV playback failed:', wavError);
                  showMessage('播放失败: ' + playError.message, 'system');
                }
              }
            }, 100);
          } catch (processError) {
            console.error('Audio processing error:', processError);
            showMessage('音频处理失败: ' + processError.message, 'system');
          }
        } else {
          showMessage('TTS服务返回错误: 缺少audioBase64字段', 'system');
        }
      } catch (error) {
        console.error('TTS Error:', error);
        showMessage('TTS请求失败: ' + error.message, 'system');
      }
    }
    
    function clearChat() {
      const chat = document.getElementById('chat');
      chat.innerHTML = '<div class="welcome-message"><p>聊天记录已清空</p><p>开始新的对话吧！</p></div>';
      lastAiText = '';
    }

    // 语音录制相关变量（更新）
    let audioContext;
    let processor;
    let audioStream;
    let isRecording = false;
    let pcmChunks = []; // 存储 PCM 数据块

    // 开始录音（采集 PCM 16kHz 单声道）
    async function startRecording() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // 创建 AudioContext，强制 16kHz 采样率
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });

        // 解决浏览器自动暂停问题
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        const source = audioContext.createMediaStreamSource(audioStream);
        // 创建缓冲区大小为 4096 的处理器（约每 256ms 触发一次 onaudioprocess）
        processor = audioContext.createScriptProcessor(4096, 1, 1); // 输入1声道，输出1声道

        source.connect(processor);
        processor.connect(audioContext.destination);

        pcmChunks = [];
        isRecording = true;

        // 实时采集 PCM 数据
        processor.onaudioprocess = (e) => {
          if (!isRecording) return;
          const inputData = e.inputBuffer.getChannelData(0); // 获取左声道 Float32Array
          const pcmData = floatTo16BitPCM(inputData);
          pcmChunks.push(pcmData);

          console.log('Captured PCM chunk, size:', pcmData.length, 'bytes');

          //  可选：实时发送分片（实现"边说边识别"）
          // sendPcmChunk(pcmData);
        };

        document.getElementById('recordButton').disabled = true;
        document.getElementById('stopRecordButton').disabled = false;
        document.getElementById('recordText').textContent = '录音中...';
        showMessage('开始录音（PCM 16kHz 单声道）...', 'system');
        console.log('Started recording with AudioContext, sample rate:', audioContext.sampleRate);

      } catch (error) {
        console.error('录音错误:', error);
        showMessage('录音失败: ' + error.message, 'system');
      }
    }

    // Float32Array 转 Int16Array 再转 Uint8Array (PCM 16-bit)
    function floatTo16BitPCM(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      for (let i = 0; i < float32Array.length; i++) {
        const s = Math.max(-1, Math.min(1, float32Array[i]));
        const val = s < 0 ? s * 0x8000 : s * 0x7FFF;
        view.setInt16(i * 2, val, true); // 小端字节序
      }
      return new Uint8Array(buffer);
    }

    // 停止录音
    function stopRecording() {
      if (!isRecording) return;

      isRecording = false;

      // 断开音频图
      if (processor) {
        processor.disconnect();
      }
      if (audioContext) {
        audioContext.close(); // 关闭上下文
      }
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
      }

      document.getElementById('recordButton').disabled = false;
      document.getElementById('stopRecordButton').disabled = true;
      document.getElementById('recordText').textContent = '开始录音';
      showMessage('录音已停止，正在识别...', 'system');

      // 合并所有 PCM 数据块
      const totalLength = pcmChunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const mergedArray = new Uint8Array(totalLength);
      let offset = 0;
      pcmChunks.forEach(chunk => {
        mergedArray.set(chunk, offset);
        offset += chunk.length;
      });

      console.log('Total PCM data collected:', totalLength, 'bytes from', pcmChunks.length, 'chunks');

      // 转为 Base64 发送
      const base64String = btoa(String.fromCharCode.apply(null, mergedArray));
      console.log('Base64 encoded PCM data length:', base64String.length);

      // 发送到后端进行 ASR 识别
      sendPcmToAsr(base64String);
    }

    async function sendPcmToAsr(pcmBase64) {
      try {
        const response = await fetch('/api/chat/asr', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            audioBase64: pcmBase64,
            format: 'pcm'  // 明确告诉后端是 PCM 数据
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log('ASR Result:', result);

        if (result.text && !result.text.includes('[ASR错误]')) {
          document.getElementById('input').value = result.text;
          showMessage('语音识别完成: ' + result.text, 'system');
          // 可选：自动发送
          startStream();
        } else {
          showMessage('语音识别失败: ' + result.text, 'system');
        }
      } catch (error) {
        console.error('ASR Error:', error);
        showMessage('语音识别请求失败: ' + error.message, 'system');
      }
    }

    // 简单 polyfill: 使用fetch+ReadableStream模拟SSE POST
    class EventSourcePolyfill{
      constructor(url, opt){
        this.controller = new AbortController();
        fetch(url, { method: opt.method||'POST', headers: opt.headers||{}, body: opt.payload||null, signal: this.controller.signal })
          .then(async resp=>{
            const reader = resp.body.getReader();
            const dec = new TextDecoder();
            while(true){
              const {value, done} = await reader.read();
              if(done) break;
              const chunk = dec.decode(value, {stream:true});
              chunk.split('\n\n').forEach(line=>{ 
                if(line.startsWith('data:')) {
                  this.onmessage && this.onmessage({ data: line.slice(5).trim() }); 
                }
              });
            }
            this.onerror && this.onerror();
          }).catch(err=>{ 
            this.onerror && this.onerror(err); 
          });
      }
      close(){ this.controller.abort(); }
    }
  </script>
</body>
</html>